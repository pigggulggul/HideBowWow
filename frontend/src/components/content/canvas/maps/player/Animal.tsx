/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/models/character/ArcticFox_Animations.glb -t -o src/components/content/canvas/maps/player/ArcticFox_Animations.tsx 
*/

import * as THREE from 'three';
import { useGLTF } from '@react-three/drei';
import { PlayerInitType } from '../../../../../types/GameType';
import { useAnimal } from './hooks/useAnimal';
import { useBox } from '@react-three/cannon';
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { useDispatch } from 'react-redux';
import { addCollideObjectState } from '../../../../../store/user-slice';
import { NicknameBoard } from '../structures/ground/3DUIs/NicknameBoard';

export function Animal({ player, position, modelIndex: mIdx }: PlayerInitType) {
    const dispatch = useDispatch();
    const modelIndex = mIdx ?? mIdx;
    const [, boxApi] = useBox(
        () => ({
            mass: 0,
            args: [1, 1, 1],
            type: 'Kinematic',
            position: [0, 0, 0], // 초기 위치를 useRef의 현재 값으로 설정
            onCollide: (e) => {
                // console.log('충돌', e);
                if (playerRef.current) {
                    const bounds = calculateBoundingBox(e.body);
                    // console.log(`X 좌표 범위: ${bounds.minX} ~ ${bounds.maxX}`);
                    // console.log(`Y 좌표 범위: ${bounds.minY} ~ ${bounds.maxY}`);
                    // console.log(`Z 좌표 범위: ${bounds.minZ} ~ ${bounds.maxZ}`);
                    dispatch(addCollideObjectState(bounds));
                } else {
                    console.log('메쉬 정보가 없습니다.');
                }
            },
        }),
        useRef(null)
    );
    const {
        meInfo,
        playerRef,
        memoizedPosition,
        playerNickname,
        nodes,
        material,
        nicknameRef,
        // ref,
    } = useAnimal({
        player,
        position,
        modelIndex,
    });

    useFrame(() => {
        if (playerRef.current) {
            const { x, y, z } = playerRef.current.position;
            boxApi.position.set(x, y, z); // 물리 바디의 속도를 업데이트
        }
    });
    function calculateBoundingBox(mesh: any) {
        // Geometry가 BufferGeometry인 경우, 필요하다면 Geometry로 변환할 수 있으나,
        // Box3.compute()는 BufferGeometry에서도 작동하므로 변환할 필요가 없습니다.
        const box = new THREE.Box3().setFromObject(mesh);

        // box.min과 box.max는 Vector3 객체로 각 축의 최소 및 최대 좌표를 포함합니다.
        return {
            minX: box.min.x,
            maxX: box.max.x,
            minY: box.min.y,
            maxY: box.max.y,
            minZ: box.min.z,
            maxZ: box.max.z,
        };
    }

    return (
        <>  
        {meInfo && (
                <NicknameBoard ref={nicknameRef} text={`${player?.nickname}`} />
        )}
        <group
            ref={playerRef}
            position={memoizedPosition}
            name={playerNickname ?? ''}
            dispose={null}
        >
            <group name="Scene">
                <group name="Rig" scale={1}>
                    <primitive object={nodes.root} />
                    <skinnedMesh
                        name="Mesh"
                        geometry={(nodes.Mesh as THREE.SkinnedMesh).geometry}
                        material={material}
                        skeleton={(nodes.Mesh as THREE.SkinnedMesh).skeleton}
                    />
                </group>
            </group>
        </group>
        </>
    );
}

useGLTF.preload('/models/character/ArcticFox_Animations.glb');
