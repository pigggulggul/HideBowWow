/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/models/object/Closet.glb -t -o src/components/content/canvas/maps/player/Closet.tsx 
*/

import * as THREE from 'three';
import { useRef } from 'react';
import { useGLTF } from '@react-three/drei';
import { PlayerInitType } from '../../../../../types/GameType';
import { useObject } from './hooks/useObject';
import { useFrame } from '@react-three/fiber';
import { useBox } from '@react-three/cannon';
import { NicknameBoard } from '../structures/ground/3DUIs/NicknameBoard';
import { useDispatch } from 'react-redux';
import { addCollideObjectState } from '../../../../../store/user-slice';

export function ObjectPlayer({
    player,
    position,
    selectedIndex: mIdx,
}: PlayerInitType) {
    const dispatch = useDispatch();
    const modelIndex = mIdx ? mIdx : 0;
    const [_, boxApi] = useBox(
        () => ({
            mass: 0,
            args: [1, 1, 1],
            type: 'Kinematic',
            position: [0, 0, 0], // 초기 위치를 useRef의 현재 값으로 설정
            onCollide: (e) => {
                // console.log('충돌', e);
                if (playerRef.current) {
                    const bounds = calculateBoundingBox(e.body);
                    // console.log(`X 좌표 범위: ${bounds.minX} ~ ${bounds.maxX}`);
                    // console.log(`Y 좌표 범위: ${bounds.minY} ~ ${bounds.maxY}`);
                    // console.log(`Z 좌표 범위: ${bounds.minZ} ~ ${bounds.maxZ}`);
                    dispatch(addCollideObjectState(bounds));
                } else {
                    console.log('메쉬 정보가 없습니다.');
                }
            },
        }),
        useRef(null)
    );
    const {
        meInfo,
        playerRef,
        memoizedPosition,
        playerNickname,
        nicknameRef,
        node,
        material,
        scale,
        initialHeight,
        // initialRotation,
    } = useObject({
        player,
        position,
        modelIndex,
    });

    useFrame(() => {
        if (playerRef.current) {
            const { x, y, z } = playerRef.current.position;
            boxApi.position.set(x, y, z); // 물리 바디의 속도를 업데이트
            // console.log(x, y, z);
        }
    });
    function calculateBoundingBox(mesh: any) {
        // Geometry가 BufferGeometry인 경우, 필요하다면 Geometry로 변환할 수 있으나,
        // Box3.compute()는 BufferGeometry에서도 작동하므로 변환할 필요가 없습니다.
        const box = new THREE.Box3().setFromObject(mesh);

        // box.min과 box.max는 Vector3 객체로 각 축의 최소 및 최대 좌표를 포함합니다.
        return {
            minX: box.min.x,
            maxX: box.max.x,
            minY: box.min.y,
            maxY: box.max.y,
            minZ: box.min.z,
            maxZ: box.max.z,
        };
    }

    return (
        <>
            {meInfo && (
                <NicknameBoard ref={nicknameRef} text={`${player?.nickname}`} />
            )}
            <group
                ref={playerRef}
                position={memoizedPosition}
                name={playerNickname ?? ''}
                dispose={null}
                scale={scale}
            >
                <mesh
                    geometry={node[0]}
                    material={material[0]}
                    name={playerNickname}
                    rotation={[Math.PI / 2, 0, 0]}
                />
                {node.length > 1 ? (
                    <mesh
                        geometry={node[1]}
                        material={material[1]}
                        name={playerNickname}
                        rotation={[Math.PI / 2, 0, 0]}
                    />
                ) : (
                    <></>
                )}
                {node.length > 2 ? (
                    <mesh
                        geometry={node[2]}
                        material={material[2]}
                        name={playerNickname}
                        rotation={[Math.PI / 2, 0, 0]}
                    />
                ) : (
                    <></>
                )}
                {node.length > 3 ? (
                    <mesh
                        geometry={node[3]}
                        material={material[3]}
                        name={playerNickname}
                        rotation={[Math.PI / 2, 0, 0]}
                    />
                ) : (
                    <></>
                )}
                {node.length > 4 ? (
                    <mesh
                        geometry={node[4]}
                        material={material[4]}
                        name={playerNickname}
                        rotation={[Math.PI / 2, 0, 0]}
                    />
                ) : (
                    <></>
                )}
                {node.length > 5 ? (
                    <mesh
                        geometry={node[5]}
                        material={material[5]}
                        name={playerNickname}
                        rotation={[Math.PI / 2, 0, 0]}
                    />
                ) : (
                    <></>
                )}
                {node.length > 6 ? (
                    <mesh
                        geometry={node[6]}
                        material={material[6]}
                        name={playerNickname}
                        rotation={[Math.PI / 2, 0, 0]}
                    />
                ) : (
                    <></>
                )}
                {node.length > 7 ? (
                    <mesh
                        geometry={node[7]}
                        material={material[7]}
                        name={playerNickname}
                        rotation={[Math.PI / 2, 0, 0]}
                    />
                ) : (
                    <></>
                )}
                {node.length > 8 ? (
                    <mesh
                        geometry={node[8]}
                        material={material[8]}
                        name={playerNickname}
                        rotation={[Math.PI / 2, 0, 0]}
                    />
                ) : (
                    <></>
                )}
                {node.length > 9 ? (
                    <mesh
                        geometry={node[9]}
                        material={material[9]}
                        name={playerNickname}
                        rotation={[Math.PI / 2, 0, 0]}
                    />
                ) : (
                    <></>
                )}
            </group>
        </>
    );
}

useGLTF.preload('/models/object/Closet.glb');
